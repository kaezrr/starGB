#include "memory.hpp"
#include "constants.hpp"
#include <fstream>
#include <memory>
#include <spdlog/spdlog.h>

u8 Memory::read(u16 at) const {
    if (at < 0x100 && execute_boot)
        return boot_rom[at];
    if (at <= ROM_E)
        return mbc->read_rom(at);
    if (at <= VRAM_E)
        return ppu->fetcher.vram[at - VRAM_S];
    if (at <= EXRAM_E)
        return mbc->read_ram(at);
    if (at <= ECHO_E)
        return wram[at & 0x1FFF];
    if (at <= OAM_E)
        return ppu->fetcher.oam[at - OAM_S];
    if (at <= FORBID_E)
        return 0x00;
    if (at <= IO_E)
        return read_IO(at);
    if (at <= HRAM_E)
        return hram[at - HRAM_S];
    return ie_reg;
}

void Memory::write(u16 at, u8 data) {
    if (at == DMA)
        initiate_dma_transfer(data);

    if (execute_boot && at == 0xFF50)
        execute_boot = false;

    if (at <= ROM_E)
        mbc->write_rom(at, data);

    else if (at <= VRAM_E)
        ppu->fetcher.vram[at - VRAM_S] = data;

    else if (at <= EXRAM_E)
        mbc->write_ram(at, data);

    else if (at <= WRAM_E)
        wram[at - WRAM_S] = data;

    else if (at <= ECHO_E)
        wram[at - ECHO_S] = data;

    else if (at <= OAM_E)
        ppu->fetcher.oam[at - OAM_S] = data;

    else if (at <= FORBID_E)
        return;

    else if (at <= IO_E)
        write_IO(at, data);

    else if (at <= HRAM_E)
        hram[at - HRAM_S] = data;

    else if (at == IE_REG)
        ie_reg = data;
}

u8 Memory::read_IO(u16 at) const {
    switch (at) {
    case SB:
        return 0xFF;
    case DIV ... TAC:
        return timer->read(at);
    case LCDC ... WX:
        return ppu->read(at);
    case IF:
        return get_intrF();
    case JOYP:
        return joypad->read();
    }
    return io_reg[at - IO_S];
}

void Memory::write_IO(u16 at, u8 data) {
    switch (at) {
    case DIV ... TAC:
        return timer->write(at, data);
    case LCDC ... WX:
        return ppu->write(at, data);
    case JOYP:
        return joypad->write(data);
    case IF:
        return set_intrF(data);
    case SC:
        if (data == 0x81) {
            data = 0x01;
            serial_intrF |= SERIAL;
        }
    }
    io_reg[at - IO_S] = data;
}

void Memory::initiate_dma_transfer(u8 data) {
    u16 src = data << 8;
    if (src >= 0xE000)
        src -= 0x2000;
    for (u16 i = 0; i < 0xA0; ++i) {
        ppu->fetcher.oam[i] = read(src + i);
    }
}

void Memory::load_boot() {
    unsigned char boot_gb[] = {
        0x31, 0xfe, 0xff, 0x21, 0x00, 0x80, 0xaf, 0x22, 0xcb, 0x6c, 0x28, 0xfb,
        0x3e, 0x80, 0xe0, 0x26, 0xe0, 0x11, 0x3e, 0xf3, 0xe0, 0x12, 0xe0, 0x25,
        0x3e, 0x77, 0xe0, 0x24, 0x3e, 0x54, 0xe0, 0x47, 0x11, 0x04, 0x01, 0x21,
        0x10, 0x80, 0x1a, 0x47, 0xcd, 0xa3, 0x00, 0xcd, 0xa3, 0x00, 0x13, 0x7b,
        0xee, 0x34, 0x20, 0xf2, 0x11, 0xd2, 0x00, 0x0e, 0x08, 0x1a, 0x13, 0x22,
        0x23, 0x0d, 0x20, 0xf9, 0x3e, 0x19, 0xea, 0x10, 0x99, 0x21, 0x2f, 0x99,
        0x0e, 0x0c, 0x3d, 0x28, 0x08, 0x32, 0x0d, 0x20, 0xf9, 0x2e, 0x0f, 0x18,
        0xf5, 0x3e, 0x1e, 0xe0, 0x42, 0x3e, 0x91, 0xe0, 0x40, 0x16, 0x89, 0x0e,
        0x0f, 0xcd, 0xb8, 0x00, 0x7a, 0xcb, 0x2f, 0xcb, 0x2f, 0xe0, 0x42, 0x7a,
        0x81, 0x57, 0x79, 0xfe, 0x08, 0x20, 0x04, 0x3e, 0xa8, 0xe0, 0x47, 0x0d,
        0x20, 0xe7, 0x3e, 0xfc, 0xe0, 0x47, 0x3e, 0x83, 0xcd, 0xcb, 0x00, 0x06,
        0x05, 0xcd, 0xc4, 0x00, 0x3e, 0xc1, 0xcd, 0xcb, 0x00, 0x06, 0x3c, 0xcd,
        0xc4, 0x00, 0x21, 0xb0, 0x01, 0xe5, 0xf1, 0x21, 0x4d, 0x01, 0x01, 0x13,
        0x00, 0x11, 0xd8, 0x00, 0xc3, 0xfe, 0x00, 0x3e, 0x04, 0x0e, 0x00, 0xcb,
        0x20, 0xf5, 0xcb, 0x11, 0xf1, 0xcb, 0x11, 0x3d, 0x20, 0xf5, 0x79, 0x22,
        0x23, 0x22, 0x23, 0xc9, 0xe5, 0x21, 0x0f, 0xff, 0xcb, 0x86, 0xcb, 0x46,
        0x28, 0xfc, 0xe1, 0xc9, 0xcd, 0xb8, 0x00, 0x05, 0x20, 0xfa, 0xc9, 0xe0,
        0x13, 0x3e, 0x87, 0xe0, 0x14, 0xc9, 0x3c, 0x42, 0xb9, 0xa5, 0xb9, 0xa5,
        0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xe0, 0x50};
    std::memcpy(&boot_rom[0], boot_gb, 0x100);
    execute_boot = true;
}

void Memory::load_game(const string& path) {
    std::ifstream program{path, std::ios::binary};
    if (!program) {
        spdlog::error("game rom not found!");
        program.close();
        std::exit(1);
    }
    program.seekg(0x147, std::ios::beg);
    u8 mbc_type;
    program >> mbc_type;
    program.close();

    switch (mbc_type) {
    case 0x00:
    case 0x08:
    case 0x09:
        mbc = std::make_unique<MBC0>(path);
        return;
    case 0x01 ... 0x03:
        mbc = std::make_unique<MBC1>(path);
        return;
    case 0x0F ... 0x13:
        mbc = std::make_unique<MBC3>(path);
        return;
    case 0x19 ... 0x1E:
        mbc = std::make_unique<MBC5>(path);
        return;
    default:
        spdlog::error("Unsupported MBC type! Emulator currently only supports "
                      "MBC1, MBC3 and MC5");
        exit(1);
    }
}

void Memory::set_intrF(u8 data) {
    joypad->intrF = data & JOYPAD;
    serial_intrF = data & SERIAL;
    timer->intrF = data & TIMER;
    ppu->intrF = data & (LCD | VBLANK);
}

u8 Memory::get_intrF() const {
    return serial_intrF | joypad->intrF | ppu->intrF | timer->intrF;
}
